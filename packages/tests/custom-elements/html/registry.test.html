<!DOCTYPE html>
<html>
  <head>
    <title>CustomElementsRegistry</title>
    <script>
      (window.customElements =
        window.customElements || {}).forcePolyfill = true;
    </script>
    <script src="../../node_modules/@webcomponents/webcomponentsjs/bundles/webcomponents-pf_js.js"></script>
    <script src="../../node_modules/@webcomponents/custom-elements/custom-elements.min.js"></script>
  </head>
  <body>
    <script type="module">
      import {runTests, assert} from '../../environment.js';
      import {safariGCBugWorkaround} from '../safari-gc-bug-workaround.js';

      runTests(async () => {
        suiteSetup(() => safariGCBugWorkaround());

        /**
         * @license
         * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
         * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
         * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
         * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
         * Code distributed by Google as part of the polymer project is also
         * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
         */

        suite('CustomElementsRegistry', function () {
          var work;
          var HTMLNS = 'http://www.w3.org/1999/xhtml';

          customElements.enableFlush = true;

          setup(function () {
            work = document.createElement('div');
            document.body.appendChild(work);
          });

          teardown(function () {
            document.body.removeChild(work);
          });

          suite('window', function () {
            test('customElements.define exists', function () {
              assert.isFunction(customElements.define);
            });
          });

          suite('define', function () {
            test('requires a name argument', function () {
              assert.throws(
                function () {
                  customElements.define();
                },
                '',
                'customElements.define failed to throw when given no arguments'
              );
            });

            test('name must contain a dash', function () {
              assert.throws(
                function () {
                  customElements.define('xfoo', class extends HTMLElement {});
                },
                '',
                'customElements.define failed to throw when given no arguments'
              );
            });

            test('name must not be a reserved name', function () {
              [
                'annotation-xml',
                'color-profile',
                'font-face',
                'font-face-src',
                'font-face-uri',
                'font-face-format',
                'font-face-name',
                'missing-glyph',
              ].forEach((invalidName) => {
                assert.throws(
                  function () {
                    customElements.define(
                      invalidName,
                      class extends HTMLElement {}
                    );
                  },
                  '',
                  `Registration should fail for name '${invalidName}'.`
                );
              });
            });

            test('name must be unique', function () {
              class XDuplicate extends HTMLElement {}
              customElements.define('x-duplicate', XDuplicate);
              assert.throws(
                function () {
                  customElements.define('x-duplicate', XDuplicate);
                },
                '',
                'customElements.define failed to throw when called multiple times with the same element name'
              );
            });

            test('names are case-sensitive', function () {
              class XCase extends HTMLElement {}
              assert.throws(function () {
                customElements.define('X-CASE', XCase);
              });
            });

            test('requires a constructor argument', function () {
              assert.throws(
                function () {
                  customElements.define('x-no-options');
                },
                '',
                'customElements.define failed to throw without a constructor argument'
              );
            });

            test('second argument prototype property is required', function () {
              assert.throws(
                function () {
                  customElements.define('x-no-proto', {});
                },
                '',
                'customElements.define failed to throw with a constructor argument with no prototype'
              );
            });

            test('fails if reading callbacks fails', function () {
              assert.throws(
                function () {
                  customElements.define(
                    'x-bad-attributes',
                    class extends HTMLElement {
                      attributeChangedCallback() {}
                      static get observedAttributes() {
                        throw new Error('no attributes');
                      }
                    }
                  );
                },
                '',
                'customElements.define failed to throw when reading callback throws.'
              );
            });

            test('succeeds with named used for a failed definition with invalid class', function () {
              try {
                customElements.define('x-failed-define', {});
              } catch (e) {} // eslint-disable-line no-empty
              let error;
              try {
                customElements.define(
                  'x-failed-define',
                  class extends HTMLElement {}
                );
              } catch (e) {
                error = e;
              }
              assert.isUndefined(
                error,
                'Error thrown when defining an element using the same name as a failed definition with an invalid class.'
              );
            });

            test('succeeds with named used for a failed definition with invalid callbacks', function () {
              try {
                customElements.define(
                  'x-failed-define-callbacks',
                  class extends HTMLElement {
                    attributeChangedCallback() {}
                    static get observedAttributes() {
                      throw new Error('no attributes');
                    }
                  }
                );
              } catch (e) {} // eslint-disable-line no-empty
              let error;
              try {
                customElements.define(
                  'x-failed-define-callbacks',
                  class extends HTMLElement {}
                );
              } catch (e) {
                error = e;
              }
              assert.isUndefined(
                error,
                'Error thrown when defining an element using the same name as a failed definition with invalid callbacks.'
              );
            });
          });

          suite('get', function () {
            test('returns a defined constructor', function () {
              class XGet extends HTMLElement {}
              customElements.define('x-get', XGet);
              assert.equal(XGet, customElements.get('x-get'));
            });

            test('returns undefined for an undefined constructor', function () {
              assert.isUndefined(customElements.get('x-undefined'));
            });
          });

          suite('getName', function () {
            test('returns the local name for a defined custom element constructor', function () {
              class XGetName extends HTMLElement {}
              customElements.define('x-get-name', XGetName);

              var name = customElements.getName(XGetName);
              assert.equal(name, 'x-get-name');
            });

            test('returns null for an undefined custom element constructor', function () {
              class XUndefinedElement extends HTMLElement {}

              var name = customElements.getName(XUndefinedElement);
              assert.isNull(name);
            });
          });

          suite('whenDefined', function () {
            test('resolves when a tag is defined', function () {
              var promise = customElements
                .whenDefined('x-when-defined')
                .then(function (r) {
                  assert.isUndefined(r);
                });
              class XDefined extends HTMLElement {}
              customElements.define('x-when-defined', XDefined);
              return promise;
            });

            test('throws for an invalid element name', function () {
              return customElements.whenDefined('div').then(
                function () {
                  assert.fail();
                },
                function () {
                  // pass
                  return;
                }
              );
            });
          });
        });
      });
    </script>
  </body>
</html>
