<!doctype html>
<html>
<head>
<title>CustomElementReactionsStack callback ordering for main document elements</title>
<script>
  (window.customElements = window.customElements || {}).forcePolyfill = true;
</script>
<script src="../../../node_modules/es6-promise/dist/es6-promise.auto.min.js"></script>
<script src="../../../node_modules/wct-browser-legacy/browser.js"></script>
<script src="../../../custom-elements.min.js"></script>
<script>
  // Inlined "../../safari-gc-bug-workaround.js". This workaround needs to be
  // applied inside this classic script because this test determines if
  // parser-created elements are constructed and have their reactions called in
  // the correct order. Also, Safari 11's native custom elements implementation
  // does not order these correctly.
  if (customElements.polyfillWrapFlushCallback === undefined) {
    window.__CE_installPolyfill();
    console.warn('The custom elements polyfill was reinstalled.');
  }

  window.LOG = [];

  window.addEventListener('custom-element:log', function(e) {
    window.LOG.push(e.detail.text);
  });

  function dispatchLogEvent(target, text) {
    var type = 'custom-element:log';
    var bubbles = true;
    var cancelable = false;
    var detail = {
      text: text,
    };

    var logEvent;
    try {
      logEvent = new CustomEvent(type, {
        bubbles: bubbles,
        cancelable: cancelable,
        detail: detail
      });
    } catch (e) {
      logEvent = document.createEvent("CustomEvent");
      logEvent.initCustomEvent(type, bubbles, cancelable, detail);
    }

    target.dispatchEvent(logEvent);
  }

  customElements.define('custom-element', class extends HTMLElement {
    constructor() {
      super();
      this.constructor.instanceCount = (this.constructor.instanceCount || 0) + 1;
      dispatchLogEvent(this, `custom-element constructor ${this.constructor.instanceCount}`);
    }

    connectedCallback() {
      dispatchLogEvent(this, `#${this.id} connected`);
    }

    disconnectedCallback() {
      dispatchLogEvent(this, `#${this.id} disconnected`);
    }

    static get observedAttributes() { return ['attr']; }
    attributeChangedCallback(name, oldValue, newValue, namespace) {
      dispatchLogEvent(this, `#${this.id} attributeChangedCallback ${name}`);
    }
  });
</script>
</head>
<body>

<custom-element id="root" attr="a">
  <custom-element id="next-0" attr="a">
    <custom-element id="next-1" attr="a"></custom-element>
  </custom-element>
</custom-element>

<script>
suite('Callback ordering for main document elements.', function() {
  test('Element reactions are queued and flushed in the correct order.', function() {
    assert.deepEqual(window.LOG, [
      'custom-element constructor 1',
      '#root attributeChangedCallback attr',
      '#root connected',
      'custom-element constructor 2',
      '#next-0 attributeChangedCallback attr',
      '#next-0 connected',
      'custom-element constructor 3',
      '#next-1 attributeChangedCallback attr',
      '#next-1 connected',
    ]);
  });
});

</script>
</body>
</html>
